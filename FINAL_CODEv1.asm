;; DECLARE ALL THE PORTS, REGISTER, DATA VALUES
; PORTS
CS_PIN:		EQU 	80H 		
SCK_PIN:	EQU	81H	
MOSI_PIN:	EQU	82H	
MISO_PIN: 	EQU	00H
;REGISTERS AND DATA
USER_CTRL: 	EQU 	6AH
I2C_MST_EN: 	EQU	20H
I2C_MST_CTRL: 	EQU	24H 
I2C_MST_CLK: 	EQU	0DH
AK8963_CNTL1: 	EQU	0AH
AK8963_PWR_DOWN: EQU	00H
PWR_MGMNT_1: 	EQU	6BH
PWR_RESET: 	EQU	80H
AK8963_CNTL2: 	EQU	0BH
AK8963_RESET: 	EQU	01H
AK8963_FUSE_ROM: EQU	0FH
AK8963_ASA: 	EQU	10H
AK8963_CNT_MEAS1: EQU 	12H
AK8963_CNT_MEAS2: EQU 	16H 
AK8963_HXL: 	EQU	03H
I2C_SLV0_ADDR: 	EQU	25H
AK8963_I2C_ADDR: EQU	0CH
I2C_SLV0_REG: 	EQU 	26H
I2C_SLV0_D0: 	EQU	63H
I2C_SLV0_CTRL: 	EQU	27H
I2C_SLV0_EN: 	EQU	80H
I2C_READ_FLAG: 	EQU	80H
EXT_SENS_DATA_00: EQU 	49H
SPI_READ: 	EQU	80H
WHO_AM_I: 	EQU	75H
AK8963_WHO_AM_I: EQU 	00H
ACCEL_OUT: 	EQU	3BH
TRANS_LENGTH: 	EQU 	08H
HXL:		EQU 	49H
HXH: 		EQU	4AH
HYL: 		EQU	4BH
HYH:		EQU	4CH 
HEAP_ADDRESS_LOW: 	EQU 00H		;; LOWER ORDER HEAP ADDRESS
HEAP_ADDRESS_HIGH: 	EQU 81H		;; HIGHER ORDER HEAP ADDRESS




;; STACK POINTER AND HEAP POINTER HXL : 8100 HXH: 8101, HYL:8102, HYH: 8103

			LXI SP,0000H 	;; LOAD STACK POINTER
MAIN:			CALL N0
			CALL DELAY_100MS
			CALL NE22
			CALL DELAY_100MS
			CALL NE45
			CALL DELAY_100MS
			CALL NE67
			CALL DELAY_100MS	
			CALL E90
			CALL DELAY_100MS
			CALL SE112
			CALL DELAY_100MS
			CALL SE135
			CALL DELAY_100MS
			CALL SE157
			CALL DELAY_100MS
			CALL S180
			CALL DELAY_100MS
			CALL SW202
			CALL DELAY_100MS
			CALL SW225
			CALL DELAY_100MS
			CALL SW247
			CALL DELAY_100MS	
			CALL W270
			CALL DELAY_100MS
			CALL NW292
			CALL DELAY_100MS
			CALL NW315
			CALL DELAY_100MS
			CALL NW337
			CALL DELAY_100MS
			RIM
			ANI 80H
			JZ START
			JMP MAIN
			
;; START IS CALLED WHEN SID SWITCH IS PRESSED, IT INITIALIZES THE MAGNEOTMETER AND JUMPS TO LOOP OUTPUT AFTER INITIALIZATION, SOD LED IS LIGHTED AFTER SUCCESSFUL INITIALIZATION
START: 			CALL SET_LED_ARRAY
			CALL DELAY_100MS	;; GIVE THE PEOPLE SOME EFFECT
			MVI B, USER_CTRL    ;; START INITIALIZATION SEQUENCE
			MVI C, I2C_MST_EN	
			CALL SPI_TRANSFER     ;; ENABLE I2C MASTER MODE
			MVI B, I2C_MST_CTRL
			MVI C, I2C_MST_CLK
			CALL SPI_TRANSFER	;; SET I2C BUS SPEED TO 400 kHz
			MVI D, AK8963_CNTL1
			MVI E, AK8963_PWR_DOWN
			CALL MAG_TRANSFER        ;; SET AK8963 TO POWER DOWN
			MVI B, PWR_MGMNT_1
			MVI C, PWR_RESET
			CALL SPI_TRANSFER 	;; RESET THE MPU
			CALL DELAY_1MS		;; WAIT FOR MPU-9250 TO POWER UP
			MVI D, AK8963_CNTL2	
			MVI E, AK8963_RESET 
			CALL MAG_TRANSFER	;;RESET AK8963
			CALL WHO_AM_I_CHECK		;; CHECK IF CORRECT VALUE
			MVI B, USER_CTRL
			MVI C,I2C_MST_EN
			CALL SPI_TRANSFER      ;; ENABLE I2C MASTER MODE
			MVI B, I2C_MST_CTRL
			MVI C, I2C_MST_CLK
			CALL SPI_TRANSFER      ;; SET I2C BUS SPEED TO 400 kHz
			CALL WHO_AM_I_AK8963
			MVI D, AK8963_CNTL1
			MVI E, AK8963_PWR_DOWN
			CALL MAG_TRANSFER       ;; AK8963 TO POWER DOWN
			CALL DELAY_100MS	;; LONG WAIT BEFORE MODE CHANGES
			MVI D, AK8963_CNTL1
			MVI E, AK8963_FUSE_ROM
			CALL MAG_TRANSFER  ;; SET AK8963 TO FUSE ROM ACCESS
			CALL DELAY_100MS
			MVI D, AK8963_CNTL1
			MVI E, AK8963_PWR_DOWN
			CALL MAG_TRANSFER
			CALL DELAY_100MS
			MVI D, AK8963_CNTL1
			MVI E, AK8963_CNT_MEAS2
			CALL MAG_TRANSFER 	;; SET AK8963 TO 16 BIT RESOLUTION 100 HZ REFRESH RATE
			CALL DELAY_100MS
			CALL RESET_LED_ARRAY
			CALL SOD_LED   ;; SUCCESSFUL INIT
			JMP LOOP_OUTPUT 
;; MAG_TRANSFER IS THE FUNCTION USED TO TRANSFER VALUES FROM AK8963 REGISTERS
;; VALUES TO TRANSMIT ARE STORED IN D AND E. B AND C ARE USED FOR SPI_TRANSFER INSIDE MAG_TRANSFER
MAG_TRANSFER: 		MVI B, I2C_SLV0_ADDR
			MVI C, AK8963_I2C_ADDR
			CALL SPI_TRANSFER ;; SET SLAVE 0 TO AK8963 AND SET FOR WRITE
			MVI B, I2C_SLV0_REG
			MOV C, D
			CALL SPI_TRANSFER  ;; SET THE REGISTER TO DESIRED AK8963 SUBADDRESS
			MVI B, I2C_SLV0_D0
			MOV C, E
			CALL SPI_TRANSFER  ;;STORE DATA FOR WRITE
			MVI B, I2C_SLV0_CTRL
			MVI A, I2C_SLV0_EN
			ORI 01H
			MOV C, A
			CALL SPI_TRANSFER  ;; ENABLE I2C AND SEND 1 BYTE
			RET
;; CHECK THE VALUE IN WHO_AM_I REGISTER OF AK8963 
WHO_AM_I_CHECK:		MVI A, WHO_AM_I 
			ORI SPI_READ	;; SET VALIE FOR READ
			MOV B ,A
			MVI C, 00H ;; DUMMY BYTE ANYWAY
			CALL SPI_TRANSFER
			MOV A, C   ;; DATA RECIEVED IN C
			CPI 71H
			RZ
			CPI 73H
			RZ
			JMP FAILED
;; CHECK THE VALUE IN AK8963_WHO_AM_I SHOULD BE 48H
WHO_AM_I_AK8963:	MVI B, I2C_SLV0_ADDR
			MVI A, AK8963_I2C_ADDR
			ORI I2C_READ_FLAG	
			MOV C, A
			CALL SPI_TRANSFER ;; SET SLAVE 0 TO AK8963 AND SET FOR READ
			MVI B, I2C_SLV0_REG
			MVI C, AK8963_WHO_AM_I
			CALL SPI_TRANSFER   ;; SET THE REGISTER TO AK8963 WHO _AM_I
			MVI B, I2C_SLV0_CTRL
			MVI A, I2C_SLV0_EN
			ORI 01H
			MOV C, A
			CALL SPI_TRANSFER ;; ENABLE I2C AND REQUEST 1 BYTE
			CALL DELAY_1MS  ;; WAIT FOR EXTERNAL DATA REGISTERS TO FILL IN
			MVI A, EXT_SENS_DATA_00
			ORI SPI_READ
			MOV B, A
			MVI C, 00H ;; DUMMY BYTE ANYWAY
			CALL SPI_TRANSFER
			MOV A, C ;; COMPARE DATA RECIEVED
			CPI 48H
			RZ
			JMP FAILED
;; LOOP OUTPUT READS SENSOR VALUES AND OUTPUTS THE DIRECTION IN LED MATRIX
;; IT CALLS GET VALUES SUBROUTINE WHICH STORES DATA IN 4 SUBSEQUENT MEMORY LOCATIONS AND 
;; THEN FETCH_VALUES FUNCTION IS CALLED WHICH READS THE MEMORY LOCATIONS IN HEAP 
;; AND STORED THE VALUES IN B, C, D, E. THEN OUTPUT DECODER IS CALLED WHICH GLOWS THE LED DEPENDING UPON THE DIRECTION BASED ON ALGORITHM

LOOP_OUTPUT:	CALL GET_VALUES  	;; STORE MAG DATA IN HEAP
		CALL FETCH_VALUES 	;; HXL: B HXH: C HYL: D, HYH: E
		;;CALL OUTPUT_DECODER 	;; OUTPUT ONE OF THE VALUES
		CALL DELAY_1MS	    	;; DELAY 20 MS
		JMP LOOP_OUTPUT	    	;; REPEAT

;; GET_VALUES SUBROUTINE OBTAINS THE HIGHER AND LOWER ORDER BYTES FROM HL

GET_VALUES: 	MVI H, HEAP_ADDRESS_HIGH ;; LOWER ORDER HEAP ADDRESS
		MVI L, HEAP_ADDRESS_LOW ;; HIGHER ORDER HEAP ADDRESS	
		MVI D, HXL  ;; STORE THE INITIAL ADDRESS 
		MVI E, 04H ;; COUNT OF NUMBER OF VALUES OBTAINED
GET_BYTE:	MOV A,D   ;; MOVE THE ADDRESS OF REUQIRED VALUE TO ACCUMULATOR
		ORI SPI_READ ;; SPI READ INDICATION
		MOV B, A 
		MVI C, 00H ;; DUMMY BYTE ANYWAY
		CALL SPI_TRANSFER ;; TRANSFER THE DATA
		MOV M, C ;; STORE REQUIRED VALUE AT M!
		INR D ;; INCREASE THE ADDRSS BY ONE TO READ THE NEXT VALUE
		INX H ;; POINT TO NEXT MEMORY LOCATION
		DCR E ;; DECREMENT COUNTER
		JNZ GET_BYTE ;; AGAIN
		RET
;; THIS SUBROUTINE FETCHES THE VALUES FROM MEMORY AND STORES IN REGISTERS B, C, D, E FOR FURTHER PROCESSING
FETCH_VALUES: 	MVI H, HEAP_ADDRESS_HIGH ;; LOWER ORDER ADDRESS 
		MVI L, HEAP_ADDRESS_LOW ;; HIGHER ORDER HEAP ADDRESS
		
		MOV B, M ;; HXL
		INX H
		MOV C, M ;;HXH
		INX H
		MOV D, M ;; HYL
		INX H
		MOV E, M ;; HYH
		
		RET		

;; THIS SUBROUTINE TAKES THE VALUES OF FOUR PARAMETERS IN REGISTER B , C, D , E AND DISPLAYS THE FINAL OUTPUT ON LED ARRAY
OUTPUT_DECODER:	MOV A, C ;; GET CASES FOR HXH
		CPI 00H ;; HXH = 0
		CZ HX_CASE_0 ;; CALL CASE WHEN HXH = 0
		MOV A, C
		CPI 00H
		RZ     ;; RETURN IF CASE IS ALREAD TAKEN CARE OF 
		
		MOV A, C ;; GET CASES FOR HXH
		CPI 01H ;; HXH = 1
		CZ HX_CASE_1 ;; CALL CASE WHEN HXH = 1
		MOV A, C
		CPI 01
		RZ     ;; RETURN IF CASE IS ALREAD TAKEN CARE OF 
		
		MOV A, C ;; GET CASES FOR HXH
		CPI 0FFH; HXH = 255
		CZ HX_CASE_255 ;CALL CASE WHEN HXH = 255
		MOV A, C
		CPI 0FFH
		RZ     ;; RETURN IF CASE IS ALREAD TAKEN CARE OF 
		
		RET ;; RETURN ANYWAYS
		
HX_CASE_0:	MOV A, E ;; GET CASES FOR HYH
		CPI 00H ;; HYH = 0
		CZ NW315 ;; CALL CASE WHEN HXH = 0
		MOV A, E
		CPI 00H
		RZ ;; RETURN IF CASE IS ALREADY TAKEN CARE OF 
		
		MOV A, E ;; GET CASES FOR HYH
		CPI 01H ;; HYH = 1
		CZ HX_CASE_0_1 ;; CALL CASE WHEN HXH = 1
		MOV A, E
		CPI 01H
		RZ ;; RETURN IF CASE IS ALREADY TAKEN CARE OF 
		
		MOV A, E ;; GET CASES FOR HYH
		CPI 0FFH ;; HYH = 255
		CZ HX_CASE_0_255 ;; CALL CASE WHEN HXH = 0
		MOV A, E
		CPI 0FFH
		RZ ;; RETURN IF CASE IS ALREADY TAKEN CARE OF 
		
		RET ;; RETURN ANYWAYS

HX_CASE_1:	MOV A, E ;; GET CASES FOR HYH
		CPI 00H ;; HYH = 0
		CZ HX_CASE_1_0 ;; CALL CASE WHEN HXH = 0
		MOV A, E
		CPI 00H
		RZ ;; RETURN IF CASE IS ALREADY TAKEN CARE OF 
		
		MOV A, E ;; GET CASES FOR HYH
		CPI 01H ;; HYH = 1
		CZ HX_CASE_1_1 ;; CALL CASE WHEN HXH = 1
		MOV A, E
		CPI 01H
		RZ ;; RETURN IF CASE IS ALREADY TAKEN CARE OF 
		
		MOV A, E ;; GET CASES FOR HYH
		CPI 0FFH ;; HYH = 255
		CZ NE45 ;; CALL CASE WHEN HXH = 0
		MOV A, E
		CPI 0FFH
		RZ ;; RETURN IF CASE IS ALREADY TAKEN CARE OF 
		
		RET ;; RETURN ANYWAYS

HX_CASE_255:	MOV A, E ;; GET CASES FOR HYH
		CPI 00H ;; HYH = 0
		CZ HX_CASE_255_0 ;; CALL CASE WHEN HXH = 0
		MOV A, E
		CPI 00H
		RZ ;; RETURN IF CASE IS ALREADY TAKEN CARE OF 
		
		MOV A, E ;; GET CASES FOR HYH
		CPI 01H ;; HYH = 1
		CZ SW225 ;; CALL CASE WHEN HXH = 1
		MOV A, E
		CPI 01H
		RZ ;; RETURN IF CASE IS ALREADY TAKEN CARE OF 
		
		MOV A, E ;; GET CASES FOR HYH
		CPI 0FFH ;; HYH = 255
		CZ SE135 ;; CALL CASE WHEN HXH = 0
		MOV A, E
		CPI 0FFH
		RZ ;; RETURN IF CASE IS ALREADY TAKEN CARE OF 
		
		RET ;; RETURN ANYWAYS

HX_CASE_0_1:	MOV A, B     ;; CASE 01 TAKES HXL AS INPUT	
		;; START THE COMPARISON FUNCTION
		CPI 59H;89
		CC SW247
		RC
		CPI 97H; 151
		CC W270
		RC
		CPI 0E4H;228
		CC NW292
		RET
HX_CASE_0_255:	MOV A, B     ;; CASE 0255 TAKES HXL AS INPUT	
		;; START THE COMPARISON FUNCTION
		CPI 50H;80
		CC SE112
		RC
		CPI 0A5H; 165
		CC E90
		RC
		CPI 0E5H;229
		CC NE67
		RET
HX_CASE_1_0:	MOV A, D     ;; CASE 10 TAKES HYL AS INPUT	
		;; START THE COMPARISON FUNCTION
		CPI 6EH;110
		CC  NE22
		RC
		CPI 0AFH ; 175
		CC N0
		RC
		CPI 0DEH;222
		CC NW337
		RET
HX_CASE_1_1:	MOV A, D     ;; CASE 11 TAKES HYL AS INPUT	
		;; START THE COMPARISON FUNCTION
		CPI 1BH ;27
		CC  SW247
		RC
		CPI 0FFH;255
		CC NE45
		RET
HX_CASE_255_0:	MOV A, D  ;; CASE 2550 TAKES HYL AS INPUT
		;; START THE COMPARISON FUNCTION
		CPI 55H ;85
		CC  SE157
		RC
		CPI 0A3H;163
		CC S180
		RC
		CPI 0F9H ;249
		CC SW202
		RET		
					
;; SPI TRANSFER SUBROUTINE TAKES INPUT IN B, C REGISTERS AND OUTPUT VALUE IS STORED IN B 
;; USES DE REGISTERS
SPI_TRANSFER: 	PUSH D
		CALL SCK_HIGH	; CLOCK STABLE AT HIGH VALUE
		CALL CS_LOW	; SELECT SLAVE
		MVI D, TRANS_LENGTH ; MOVE NUMBER OF BITS TO TRANSFER IN D
SEND_ADDRESS:	CALL SCK_LOW ; START TRANSFER
		MOV A, B ; MOVE REGISTER ADDRESS IN ACCUMULATOR TO TRANSFER
		ANI 80H ; AND 0X80 WITH B
		OUT MOSI_PIN; OUT 0 IF MSB IS 0 AND 1 IF MSB IS 1
ROTATE:		MOV A, B ; MOVE B IN ACCUMULATOR
		RLC; MSB TRANSMITTED - ROTATE NOW
		MOV B , A ; MOVE BACK
LATCH_INPUT:	CALL SCK_HIGH ; LATCH THE INPUT,DC STATIC 
OBTAIN_BIT:	IN 00H ; GET THE RECIEVED BYTE
		ORA A; REFLECT BIT VLAUE IN ACCUMULATOR
		JNZ SET_LSB ;MISO IS 1
RESET_LSB:	MOV A, B; MOVE INTO ACCUMULATOR
		ANI 0FEH; AND WITH 0 FEH TO RESET LSB
		MOV B, A; MOVE BYTE BACK IN B
		JMP NEXT
SET_LSB:	MOV A, B; MOVE INTO ACCUMULATOR
		ORI 01H; SET LSB
		MOV B, A; MOVE BYTE BACK IN B				
NEXT: 		DCR D
		JNZ SEND_ADDRESS

		MVI D, TRANS_LENGTH ; MOVE NUMBER OF BITS TO TRANSFER IN D
SEND_DATA:	CALL SCK_LOW ; START TRANSFER
		MOV A, C ; MOVE DATA IN ACCUMULATOR TO TRANSFER
		ANI 80H ; AND 0X80 WITH C
		OUT MOSI_PIN; OUT 0 IF MSB IS 0 AND 1 IF MSB IS 1
ROTATEd:	MOV A, C ; MOVE B IN ACCUMULATOR
		RLC; MSB TRANSMITTED - ROTATE NOW
		MOV C , A ; MOVE BACK
LATCH_INPUTd:	CALL SCK_HIGH ; LATCH THE INPUT,DC STATIC 
OBTAIN_BITd:	IN 00H ; GET THE RECIEVED BYTE
		ORA A; REFLECT BIT VLAUE IN ACCUMULATOR
		JNZ SET_LSBd ;MISO IS 1
RESET_LSBd:	MOV A, C; MOVE INTO ACCUMULATOR
		ANI 0FEH; AND WITH 0 FEH TO RESET LSB
		MOV C, A; MOVE BYTE BACK IN B
		JMP NEXTd
SET_LSBd:	MOV A, C; MOVE INTO ACCUMULATOR
		ORI 01H; SET LSB
		MOV C, A; MOVE BYTE BACK IN B
NEXTd: 		DCR D
		JNZ SEND_DATA
		CALL CS_HIGH
		POP D
		RET		
; UTILITY FUNCTIONS
CS_HIGH:	MVI A, 80H
		OUT 80H
		RET
CS_LOW:		MVI A, 00H
		OUT 80H
		RET
SCK_HIGH:	MVI A, 80H
		OUT 81H
		RET
SCK_LOW:	MVI A, 00H
		OUT 81H
		RET
SOD_LED: 	MVI A, 80H
		ORI 40H
		SIM
		RET				
N0: 	MVI A, 0FEH
	OUT 83H
	MVI A, 0FFH
	OUT 84H
	RET
NE22: 	MVI A, 0FDH
	OUT 83H
	MVI A, 0FFH
	OUT 84H
	RET
NE45: 	MVI A, 0FBH
	OUT 83H
	MVI A, 0FFH
	OUT 84H
	RET
NE67: 	MVI A, 0F7H
	OUT 83H
	MVI A, 0FFH
	OUT 84H
	RET
E90: 	MVI A, 0EFH
	OUT 83H
	MVI A, 0FFH
	OUT 84H
	RET
SE112: 	MVI A, 0DFH
	OUT 83H
	MVI A, 0FFH
	OUT 84H
	RET
SE135: 	MVI A, 0BFH
	OUT 83H
	MVI A, 0FFH
	OUT 84H
	RET
SE157: 	MVI A, 7FH
	OUT 83H
	MVI A, 0FFH
	OUT 84H
	RET
S180: 	MVI A, 0FEH
	OUT 84H
	MVI A, 0FFH
	OUT 83H
	RET
SW202: 	MVI A, 0FDH
	OUT 84H
	MVI A, 0FFH
	OUT 83H
	RET
SW225: 	MVI A, 0FBH
	OUT 84H
	MVI A, 0FFH
	OUT 83H
	RET
SW247: 	MVI A, 0F7H
	OUT 84H
	MVI A, 0FFH
	OUT 83H
	RET
W270: 	MVI A, 0EFH
	OUT 84H
	MVI A, 0FFH
	OUT 83H
	RET
NW292: 	MVI A, 0DFH
	OUT 84H
	MVI A, 0FFH
	OUT 83H
	RET
NW315: 	MVI A, 0BFH
	OUT 84H
	MVI A, 0FFH
	OUT 83H
	RET
NW337: 	MVI A, 7FH
	OUT 84H
	MVI A, 0FFH
	OUT 83H
	RET
DELAY:	PUSH B
	MVI B, 7BH
DELAYLoop1:	MVI C, 0E7H
DELAYLoop2:	DCR C
	   	JNZ DELAYLoop2
	   	DCR B
	   	JNZ DELAYLoop1
	   	POP B
		RET

DELAY_100MS:	PUSH B
	   	LXI B, 208CH
DELAY_100MSLoop:	NOP
			DCX B
	   		MOV A,B
	   		ORA C
	   		JNZ DELAY_100MSLoop
	   		POP B
			RET
DELAY_1MS:  	PUSH B
	   	LXI B,0052
DELAY_1MSLoop:	DCX B
	   	MOV A,B
	   	ORA C
	   	JNZ DELAY_1MSLoop
	   	POP B
		RET

DELAY_20MS:	PUSH B
		LXI B,0681
DELAY_20MSLoop:	DCX B
		MOV A,B
	   	ORA C
	   	JNZ DELAY_20MSLoop
	   	POP B
		RET
;; RESET LED_ARRAY: ALL PORTS ARE HALTED
RESET_LED_ARRAY: 	MVI A, 0FFH
			OUT 83H
			OUT 84H
			RET
SET_LED_ARRAY: 		MVI A, 00H
			OUT 83H
			OUT 84H
			RET
;; FAILED : OUTPUT LED'S ARE STOPPED , ONLY SOD IS LIGHTED
FAILED: 	CALL SET_LED_ARRAY
		CALL SOD_LED
		HLT	
		
	
		
			 